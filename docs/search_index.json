[["index.html", "Git/GitHubによるプロジェクト管理 はじめに", " Git/GitHubによるプロジェクト管理 Last updated: September 24, 2021 はじめに このウェブサイトは、『経済セミナー』（日本評論社刊）10・11月号の、西田貴紀・Juan Martínez・小松尚太「実証研究マネジメントのためのツールキット (1): Git/GitHubによるプロジェクト管理」のサポートページです。 Git/GitHubの使い方のチュートリアルの紹介や、研究プロジェクトの生産性を向上させる Git/GitHub の使い方についてご紹介しています。 こちらのページの内容は発展途上であり、筆者自身試行錯誤を重ねながら今後も継続的にアップデートを加えていきます。 ご意見・ご要望などありましたら歓迎いたします。 "],["useful-resources.html", "1 Useful resources 1.1 Git/GitHubの使い方に関するチュートリアル 1.2 GitのGUIツールについて", " 1 Useful resources 1.1 Git/GitHubの使い方に関するチュートリアル 経済セミナーの原稿では、Git/GitHubの使い方について必要最小限に述べるにとどめた。Git/GitHubの使い方により慣れたい場合は、以下のMicrosoftによるチュートリアルが詳しい。Microsoft accountを持っていれば、Gitのコマンドの使い方の演習も無料で行うことができる。 Gitでのバージョンコントロールの概要 https://docs.microsoft.com/ja-jp/learn/paths/github-administration-products/ GitHub の基礎 - 管理の基本と製品の機能 https://docs.microsoft.com/ja-jp/learn/paths/github-administration-products/ 1.2 GitのGUIツールについて 経済セミナー本誌ではGitをコマンドラインから扱う方法を取り扱った。コマンドライン操作に慣れていない人であれば、上記のチュートリアルでGitの概念を学習したあと、実際の運用でGitのGUIツールを使うのも良いだろう。 Gitを扱うGUIツールの代表例としては、GitHub Desktopがある。一部日本語の翻訳が追いついていない部分もあるが、公式のチュートリアルが充実している。 GitHub Desktopの使い方 https://docs.github.com/ja/desktop "],["writing-paper.html", "2 Git/GitHubを用いて論文を執筆する 2.1 論文作業のワークフロー 2.2 LaTeX の作業環境の整備 2.3 継続的インテグレーションにより、GitHub 上で自動的にコンパイルする", " 2 Git/GitHubを用いて論文を執筆する 経済セミナー本稿では分析用のコード作成を例として、Issueの作成、コミット、プッシュ、プルリクエストの作成、ブランチのマージ、以上の一連の作業過程を概観した。 このワークフローは分析用のコードの管理のみならず、共同で論文を執筆する場合にも有用である。特に LaTeX を用いて論文を執筆する際はソースコードがテキストファイルであるので、Git での管理に向いている1。 ここでは Git/GitHub を用いた、LaTeX による論文執筆の一例を紹介する。 本章はこちらの記事を大いに参考にしている。 使用するGitHubのリポジトリはこちら。 2.1 論文作業のワークフロー 基本的なワークフローは、経済セミナー本誌で紹介したものと変わらない。 研究テーマ単位でリポジトリを作成する。 執筆上の課題を明確化し、Issue を立てる。 Issue を解決するためにブランチを切り、その上で執筆を進める。 作業を適宜区切り、コミットする。各コミットがどの Issue に対応したものかを、コミットメッセージに言及しておく。 作業が完了したら pull request を作成し、共著者の確認を得る。pull request のマージをもって、Issue への対応を完了する。 このワークフローは、査読対応時も同様に適用できる。 2.1.1 研究テーマ単位でリポジトリを作成する 各研究プロジェクト毎にリポジトリを作成し、その中で論文を管理する用のディレクトリ、例えば papers のようなものを準備しておく。 論文執筆に使う tex ファイルをこの中に保存しておき、そのファイルに変更を加えていく。 2.1.2 執筆上の課題を明確化し、Issue を立てる 執筆上の課題を Issue に立て、そこで共著者間で議論を行い、方針を整理する。 各 Issue にはラベルを付けることができる。 例えば Reviewer #1 のあるコメントに対応する Issue を立てるときは、そのコメント内容を Issue にコピーアンドペーストする。 そして Reviewer #1 のようなラベルを作成し、そのラベルをつけておく。 ラベルをふっておくことで、後にフィルタリングを行うことが容易になる。 2.1.3 Issue を解決するためにブランチを切り、その上で執筆を進める ブランチを切る前に、まず現在の状態 (どのブランチにいるのかを含む) をgit statusで確認しておく習慣をつけておこう。 $ git status On branch main Your branch is up to date with &#39;origin/main&#39;. nothing to commit, working tree clean 以下のようにmainからブランチを切り、そのブランチ上で作業を進める。 $ git checkout -b feature/cite-ref Switched to a new branch &#39;feature/cite-ref&#39; 2.1.4 作業を適宜区切り、コミットする。各コミットがどの Issue に対応したものかを、コミットメッセージに言及しておく 参考文献情報を管理するファイル report.tex を作成し、本文で Issue で言及した文献を引用した。ここで git status で現在の状態を確認する。 $ git status On branch feature/cite-ref Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: report.tex Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) report.bib no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) report.tex に変更が加えられたこと、report.bib が新しく作成されたファイルでトラックされていないことが確認できる。 git diffを行うと、変更が加えられたファイル (ここでは report.tex) の変更の差分を確認できる。 $ git diff diff --git a/papers/report.tex b/papers/report.tex index 33bb60f..4403028 100644 --- a/papers/report.tex +++ b/papers/report.tex @@ -9,12 +9,17 @@ \\usepackage{here} \\usepackage{url} \\usepackage{listings} +\\usepackage{natbib} \\begin{document} + \\maketitle \\section{Introduction} -This is a test. +\\citet{knittel2018working} is a good reference for data management issues in empirical research projects. + +\\bibliography{report} +\\bibliographystyle{aer} -\\end{document} +\\end{document} \\ No newline at end of file ステージングされて以内全てのファイルをステージングさせるときは git add -u で行える。 今回はトラックされていない report.bib も加えたいので、git add report.tex report.bib とステージングさせるファイル名を指定しておく。 ステージングが終わったら、いつものように git status で確認しておく。 $ git add report.tex report.bib $ git status On branch feature/cite-ref Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: report.bib modified: report.tex 2つのファイルが無事ステージングされたことが確認できた。この状態でコミットすると、この2つのファイルの現在の状況が記録される。 それでは、この状態でコミットを行う。コミットメッセージ内で Issue の番号を入れておくと、プッシュしたときにそのコミットが Issue と紐付けられる。 こうすることで、どのコミットによって Issue に関連した変更を加えたのかの追跡が容易になる。 今取り組んでいる Issue の番号は #4 であるから、この番号をコミットメッセージに含めておく。 $ git commit -m &quot;Cite Knittel and Metaxoglou (2018) #4&quot; [feature/cite-ref 681c5a4] Cite Knittel and Metaxoglou (2018) #4 2 files changed, 16 insertions(+), 2 deletions(-) create mode 100644 papers/report.bib 2.1.5 作業が完了したら pull request を作成し、共著者の確認を得る。pull request のマージをもって、Issue への対応を完了する ファイルの変更とコミットを繰り返して Issue が解決できたら、pull request を作成して共著者の確認をもらう。 一度、これまでのコミット履歴を確認しよう。 これまでローカルリポジトリで加えた変更が、まだリモートリポジトリに反映されていない。 $ git log -2 --oneline 681c5a4 (HEAD -&gt; feature/cite-ref) Cite Knittel and Metaxoglou (2018) #4 12fa052 (origin/main, origin/HEAD, main) Prepare a docker-latex environment on VSCode HEAD -&gt; feature/cite-ref は、現在ローカルで使用しているブランチが feature/cite-ref であり、その先頭を表している。リモートリポジトリには、feature/cite-ref ブランチがまだ作成されていない。 そこで、これまでローカルリポジトリで加えた変更をリモートリポジトリにプッシュして反映させる。 $ git push origin feature/cite-ref Enumerating objects: 8, done. Counting objects: 100% (8/8), done. Delta compression using up to 16 threads Compressing objects: 100% (5/5), done. Writing objects: 100% (5/5), 796 bytes | 796.00 KiB/s, done. Total 5 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 2 local objects. remote: remote: Create a pull request for &#39;feature/cite-ref&#39; on GitHub by visiting: remote: https://github.com/komatsuna4747/gitpractice/pull/new/feature/cite-ref remote: To github.com:komatsuna4747/gitpractice.git * [new branch] feature/cite-ref -&gt; feature/cite-ref リモートリポジトリに feature/cite-ref が新しく作られたことがわかる2。 なお現在いるブランチをリモートにプッシュする際は、ブランチ名を入力する必要はなく、HEADのみで十分である。 $ git push origin HEAD もう一度ログを確認してみる。 $ git log -2 --oneline 681c5a4 (HEAD -&gt; feature/cite-ref, origin/feature/cite-ref) Cite Knittel and Metaxoglou (2018) #4 12fa052 (origin/main, origin/HEAD, main) Prepare a docker-latex environment on VSCode origin とはリモートリポジトリ (GitHub) のことを指すのであったから、feature/cite-ref ブランチのリモートリポジトリの先頭は origin/feature/cite-ref である。 したがって、ローカルとリモートの feature/cite-ref の先頭が同じ位置にいることがわかる。 さて、変更がリモートに反映されたので、GitHubから pull request を作成する。 pull request の説明欄に、対応する Issue の番号を書き、Fixed、Closed などを書いておくと、この pull request がマージされたときに自動的に参照された Issue もクローズされる。 レビューする側は、加えられた変更に対してコメント、変更の提案を行うことができる。レビューを依頼した側は、提案を受け入れて変更しコミットすること (Commit suggestion) もできる。 このあたりは、Word でコメントしたり変更を加えたりするのと似ているが、Word と比較するとコメントのやり取りや変更の過程をより詳しく記録しておくことが可能である。 レビューが終わり、無事承認されたら、pull requestをマージして、Issue への対応を終了とする。 2.2 LaTeX の作業環境の整備 これまでLaTeXによる作業環境がすでに整っていることを前提として話をしていた。 しかし LaTeX の環境構築はそれなりに面倒である。 特に共同で論文を書くときは、各人のパソコンに LaTeX 環境を構築する必要があること、ある人のパソコンでうまくいく処理が他の人のパソコンではうまくいかないことなどハードルも高い。 LaTeX の環境構築の努力を必要最小限に抑えられる、2つの方法を紹介する。 2.2.1 Overleaf の活用 Overleaf とは、オンラインの共同 LaTeX エディタである。執筆が全てオンラインで完結するので、ユーザー登録さえしてしまえばLaTeX に関する環境構築を手元で行う必要はない。 https://ja.overleaf.com/ 環境構築が必要ないことに加え、 共著者が同時に編集を加えることができる Word のようにコメントや修正を加えることができる Git や GitHub と連携することができる (GitHub との連携は有料) などの機能があり、便利である。 Overleaf と GitHub の連携では、Overleaf または GitHub 上で加えられた変更をそれぞれ push/pull することができる。 この場合、GitHub で対応するブランチは default branch であり、通常これは main branch である3。 Using Git and GitHub (公式のドキュメント) https://www.overleaf.com/learn/how-to/Using_Git_and_GitHub その便利さの一方、Overleaf ではブランチを切って各人が別に執筆を進めるという機能が現時点では存在しない。したがって Overleaf のみで無秩序に執筆を続けていくと、コメントや修正が込み入ってくると、誰のコメントにいつ対応したか、ある修正がいつ行われたかがプロジェクトが長期化するにつれて曖昧になってくる。 Overleaf を用いて共同で執筆を行う場合、上記の問題をどう解決するかは検討の余地がある。 Git/GitHub を用いた論文執筆のメリットは、こうしたコメント・修正を Issue・コミット・pull request を通じて記録できることにある。 2.2.2 Docker + VSCode の活用 LaTeX を用いた執筆の鬼門は、その環境構築にある。 その環境構築の問題を Docker によって解決しようというのが2つ目のアプローチである。 Docker の詳細は経済セミナーの第2回目の連載に譲るが、LaTeX が使える環境が整った コンテナ (container) という仮想環境を作成し、その中でコンパイルするという方法である。 この Docker を使った利点は、 同じ LaTeX 環境を複数人が容易に構築することができる 自分のローカル環境を汚さずに、LaTeX の執筆環境を作成することができる。必要がなくなれば消すことも容易である。 などが挙げられる。 Visual Studio Code、略して VSCode はエディタの1つであり、数多くの拡張機能によって好みの開発環境を容易に構築することが可能である。 VSCode と Docker を組み合わせて LaTeX の環境構築を行う方法は、検索すれば多数ヒットする。 爆速で日本語LaTeX執筆環境を用意する https://korosuke613.hatenablog.com/entry/2019/06/24/171246 To do: この続きを書く。 2.3 継続的インテグレーションにより、GitHub 上で自動的にコンパイルする 共著者の中には論文をチェックできれば良い人もいるため、そういう人にとっては tex ファイルをプルしてコンパイルする作業が面倒であったりする。 コンパイルできる人がローカルで pdf を作成し、それをリモートリポジトリにプッシュするのも良いだろうが、プッシュし忘れて、tex ファイルのバージョンと pdf ファイルのバージョンが食い違ったりすることもあり得る。 手作業による運用は往々にしてミスを生みがちなので、この辺を自動化したい。 つまり、 tex ファイルだけをプッシュすれば GitHub が勝手にコンパイルしてくれたりしないだろうか。 それを可能にする機能の1つが、GitHub Actions である。GitHub Actions とは、開発者のワークフローを GitHub 上で自動化するためのツールである。 https://github.com/features/actions 執筆者がローカルで tex file をコンパイルして、pdf ファイルをアップロードする一連のワークフローを GitHub Actions にお任せしたい。 このように、ローカルで手動で行っていたワークフローを自動化し、プログラムに変更があるたびに都度ビルド・テストをを行える環境を作ることを、継続的インテグレーション (Continuous Integration: CI) と呼ぶ。 始め方は、リポジトリのルートディレクトリに .github/workflowというディレクトリを作り、その中に yaml ファイルを作成すればよい。 これは GitHub の Actions からも作成することは可能である。 ひとまず komatsuna4747/gitpractice/.github/workflow に以下のような main.yamlを作成した。 今回のワークフローの自動化では、こちらを利用している4。 # This is a basic workflow to help you get started with Actions name: Build LaTeX document # Controls when the workflow will run on: push: paths: - &#39;papers/report.tex&#39; jobs: build_latex: runs-on: ubuntu-latest steps: - name: Set up Git repository uses: actions/checkout@v2 - name: Compile LaTeX document uses: xu-cheng/latex-action@v2 with: working_directory: papers root_file: report.tex - name: Copy PDF file run: mkdir docs &amp;&amp; cp papers/*.pdf docs/ - name: Deploy pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs To do: この詳細を書く。若干微調整している。 書かれてある内容の詳細は省くが、このファイルを容易することで、変更が加えられた tex ファイルが GitHub のリポジトリにプッシュされるごとに tex ファイルがコンパイルされて pdf が作成され 作成された pdf ファイルが gh-pages というブランチにプッシュされる 以上を自動的に行ってくれるようになる。したがって pdf ファイルだけを見たい人は、gh-pages の pdf をダウンロードして読めばよいことになる。 さらに、変更が加えられた tex ファイルがプッシュされるごとに、gh-pages の pdf も更新されるので、tex のファイルのバージョンと pdf のバージョンが常に最新版でリンクするようになるわけである。 実際にどのように動くのかを見てみよう。 まず、tex ファイルに以下のような変更を加えてコミットし、プッシュする。 $ git diff diff --git a/papers/report.tex b/papers/report.tex index 117cbb2..327440f 100644 --- a/papers/report.tex +++ b/papers/report.tex @@ -17,7 +17,7 @@ \\section{Introduction} -\\citet{knittel2018working} is a good reference for data management issues in empirical research projects. +\\citet{knittel2018working} is a good reference for empirical research projects. \\bibliography{report} \\bibliographystyle{aer} $ git add -u $ git status On branch feature/check-ci Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: report.tex $ git commit -m &quot;Make a change&quot; [feature/check-ci 482bf95] Make a change 1 file changed, 1 insertion(+), 1 deletion(-) $ git status On branch feature/check-ci nothing to commit, working tree clean $ git push origin HEAD Enumerating objects: 7, done. Counting objects: 100% (7/7), done. Delta compression using up to 16 threads Compressing objects: 100% (4/4), done. Writing objects: 100% (4/4), 345 bytes | 345.00 KiB/s, done. Total 4 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 3 local objects. remote: remote: Create a pull request for &#39;feature/check-ci&#39; on GitHub by visiting: remote: https://github.com/komatsuna4747/gitpractice/pull/new/feature/check-ci remote: To github.com:komatsuna4747/gitpractice.git * [new branch] HEAD -&gt; feature/check-ci 変更が加えられた tex ファイルがプッシュされたので、以下のようにコンパイルをするための準備、およびコンパイルが始まった。 しばらく待つと、全ての作業が完了した。どこかで失敗が起こった場合、登録したメールアドレスの方に GitHub Actions のワークフローが失敗した通知が届く。 gh-pages ブランチの pdf ファイルを見ると、確かに変更が反映された pdf がアップロードされていることがわかる。 過去の pdf をみたい場合は、そのファイルの history からたどることができる。 tex のソースファイルを見たくない共著者にはこの pdf を共有して、コメントをもらえばよい。 この GitHub Actions を用いた継続的インテグレーションは、tex ファイルのコンパイルだけでなく、分析コードのビルド・単体テスト、分析コードの実行の自動化にも応用可能である。 このあたりは別途書いてみたい。 2.3.1 注意点 GitHub Actions は、 パブリックリポジトリだと無料 プライベートリポジトリだと、以下の無料枠を使い切ったあとは従量課金制である Free アカウントだと 2000分/月まで無料 Pro アカウントだと 3000分/月まで無料 なので GitHub Actions の使い方を練習したい場合は、念の為パブリックリポジトリで行うほうが良いだろう。 また上記の tex ファイルのコンパイルの自動化も、1回あたり数分で終わるため、よほど何回も変更が加えられた tex ファイルをプッシュしない限り、月の無料枠を使い切ることは考えにくい。 WordファイルもGitでバージョン管理することは可能であるが、前回と比較してどの部分に変更を加えたかという差分を表示することができない。 Wordファイルなどのバイナリファイル (binary file) は、Git での管理にはあまり向いていない。↩︎ origin/HEAD は、リモートリポジトリ origin をクローンした時にダウンロードされるコミットの位置を表す。 通常 origin/master と同じ位置を指す。↩︎ Setting により、default branch は変更することが可能である。↩︎ 本来は、ローカルで Docker を用いた LaTeX 環境と同じもので GitHub 上でもコンパイルできるようにした方が理想である↩︎ "],["branch-strategy.html", "3 ブランチ戦略 3.1 Git Flow 3.2 Git Flow のメリット 3.3 研究プロジェクトにおける git-flow の活用？", " 3 ブランチ戦略 ブランチ戦略 (branching strategy)とは、ブランチをどのように切り、どのようにマージし、そして運用に乗せていくかという戦略のことである。Gitで他の人の作業を邪魔せずにファイルに変更を加えていくための機能をブランチ (branch) と呼ぶのであったが、作業を進めていくうちこのブランチをどのように効率的に運用すべきかという疑問が浮かぶ。各々が好き勝手にブランチを切りそしてマージしてしまうと、チーム全体が混乱に陥ることは容易に想像できる。チーム内でブランチの運用を定義しておくことで効率的なプロジェクトの遂行を実現すること、これがブランチ戦略を定める目的である。 以下、代表的なブランチモデルであるGit Flow を紹介する。 3.1 Git Flow git-flowは、Vincent Driessen が2010年に提案したブランチモデルである (詳細はこちら)。以下の図が git-flow の概観図である。 git-flowでは、役割が決められた以下の5種類のブランチを適宜切り替えながら、開発を進めていく。 3.1.1 メインブランチ (main branch) Gitリポジトリの作成時に作成されるブランチである。Git Flowではメインブランチに直接コミットすることはない。システム開発で、実際にシステムが稼働している環境を本番環境 (production environment) というが、メインブランチは本番環境でシステムが稼働しているプログラムのみが反映されるブランチである。 3.1.2 開発ブランチ (development branch) 開発ブランチは、本番環境に移行される前のプログラムを保管するためのブランチであり、開発の中心となる。メインブランチと並行しており、削除されることはない。 3.1.3 機能ブランチ (feature branch) 主に、新しい機能を加える作業を行うためのブランチであり、開発ブランチから派生させる。変更を加えるごとに作成されるため、最も頻繁に作成されるブランチである。 3.1.4 リリースブランチ (release branch) 開発したプログラムを本番環境にリリースするために、開発ブランチから派生されるブランチである。リリースに向けた作業が完了したら、メインブランチにマージされる。 3.1.5 Hotfixブランチ (hotfix branch) 発覚したバグを修正するための応急処置用のブランチである。メインブランチから派生され、バグの修正が完了したらメインブランチと開発ブランチの両方にマージされる。 3.2 Git Flow のメリット Git Flowを採用するメリットとしては、以下が挙げられる。 本番環境にリリースしたプログラム (main branch) と、開発中のプログラム (develop branch) の区別が明確になる リリースした内容の調査は main branch を参照すればよいので簡単になる git-flow用のコマンドでほとんどの管理を行えるので、操作マニュアルを用意しやすい git-flow のインストールの詳細はこちら https://github.com/nvie/gitflow/wiki/Installation などが挙げられる。デメリットとしては、上のブランチの概要図を見てもわかるように運用が複雑になる点である。 3.3 研究プロジェクトにおける git-flow の活用？ 研究プロジェクトにおけるリリースは、working paperの公開およびその改訂 (査読対応含む) に対応すると思われる。 working paper公開時に 実行可能な分析コード そのコードを走らせて得られた分析結果 原稿 これらをセットで保存しておきたい。git-flow で言えば、 普段の開発は develop branch で行い、 working paper が公開できそうになったら relase branch で準備 リリースが完了したら main と develop 両方にマージ main にマージされる毎に、タグを付けておく 以上の手順との相性が良いように思われる。こうすることで、プロジェクトの差分が main ブランチに反映され、追跡が容易になる。 「良いように思われる」と書いたのは、こうしたブランチ戦略で研究プロジェクトをまだ遂行したことがないからである。 今後、筆者が取り組む研究プロジェクトで取り入れてみて、本内容を適宜アップデートしたい。 "]]
